<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>kubectl-neat-for-web</title>
  <script src="https://unpkg.com/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Highlight.js for YAML syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
  
  <style>
    .editor-container {
      position: relative;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background: white;
      font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 14px;
    }
    
    .editor-textarea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 12px;
      border: none;
      outline: none;
      background: transparent;
      color: transparent;
      caret-color: #374151;
      font-family: inherit;
      font-size: inherit;
      line-height: 1.5;
      resize: none;
      z-index: 2;
    }
    
    .editor-highlight {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 12px;
      border: none;
      background: transparent;
      font-family: inherit;
      font-size: inherit;
      line-height: 1.5;
      overflow: hidden;
      pointer-events: none;
      z-index: 1;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    .editor-container.readonly .editor-textarea {
      color: #374151;
      background: #f8fafc;
    }
    
    .editor-container.readonly .editor-highlight {
      background: #f8fafc;
    }
    
    .line-numbers {
      position: absolute;
      left: 0;
      top: 0;
      width: 40px;
      height: 100%;
      background: #f3f4f6;
      border-right: 1px solid #e5e7eb;
      padding: 12px 8px;
      font-size: 12px;
      line-height: 1.5;
      color: #6b7280;
      user-select: none;
      z-index: 0;
    }
    
    .editor-container .editor-textarea,
    .editor-container .editor-highlight {
      padding-left: 52px;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen text-gray-800">

  <div class="max-w-4xl mx-auto p-6">
    <h1 class="text-4xl font-bold text-center text-blue-700 mb-2">kubectl-neat-for-web</h1>
    <p class="text-center text-sm text-gray-600 mb-6">
      üßπ A browser-based tool to clean up noisy <code>kubectl get ... -o yaml</code> outputs.
    </p>

    <div class="bg-yellow-100 border border-yellow-300 text-yellow-800 p-4 rounded mb-6 text-sm">
      ‚ö†Ô∏è This tool runs entirely in your browser. No files are uploaded. Safe for local use!
    </div>

    <div class="mb-4">
      <label class="block font-semibold mb-2">Select input mode:</label>
      <div class="flex gap-4">
        <label class="inline-flex items-center">
          <input type="radio" name="mode" value="paste" checked onchange="toggleInputMode()" class="mr-2" />
          Paste YAML
        </label>
        <label class="inline-flex items-center">
          <input type="radio" name="mode" value="upload" onchange="toggleInputMode()" class="mr-2" />
          Upload YAML files/folders
        </label>
      </div>
    </div>

    <div id="pasteContainer" class="mb-4">
      <label class="block font-semibold mb-2">Paste YAML content:</label>
      <div class="editor-container" style="height: 250px;">
        <div class="line-numbers" id="input-line-numbers"></div>
        <pre class="editor-highlight" id="input-highlight"></pre>
        <textarea id="input" class="editor-textarea" placeholder="# Paste your kubectl YAML here..."></textarea>
      </div>
    </div>

    <div id="uploadContainer" class="mb-4" style="display: none;">
      <label class="block font-semibold mb-2">Upload .yaml/.yml files or folders:</label>
      <div class="space-y-2">
        <div>
          <input type="file" id="fileInput" accept=".yaml,.yml" multiple class="border p-2 rounded bg-white w-full" />
          <p class="text-sm text-gray-600 mt-1">Select multiple YAML files</p>
        </div>
        <div>
          <input type="file" id="folderInput" webkitdirectory class="border p-2 rounded bg-white w-full" />
          <p class="text-sm text-gray-600 mt-1">Select a folder containing YAML files</p>
        </div>
      </div>
    </div>

    <button onclick="neat()" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 font-semibold mb-6">
      üßπ Neaten
    </button>

    <div>
      <label class="block font-semibold mb-2">Neatened Output:</label>
      <div class="editor-container readonly" style="height: 350px;">
        <div class="line-numbers" id="output-line-numbers"></div>
        <pre class="editor-highlight" id="output-highlight"></pre>
        <textarea id="output" class="editor-textarea" readonly placeholder="# Results will appear here..."></textarea>
      </div>
      
      <div id="downloadSection" class="mt-4" style="display: none;">
        <div class="flex flex-wrap gap-2">
          <button id="copyButton" onclick="copyToClipboard()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 font-semibold">
            üìã Copy to Clipboard
          </button>
          <button id="downloadSingle" onclick="downloadSingleFile()" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 font-semibold">
            üìÑ Download as YAML
          </button>
          <button id="downloadMultiple" onclick="downloadMultipleFiles()" class="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 font-semibold" style="display: none;">
            üìÅ Download Individual Files
          </button>
          <button id="downloadZip" onclick="downloadAsZip()" class="bg-orange-600 text-white px-4 py-2 rounded hover:bg-orange-700 font-semibold" style="display: none;">
            üóúÔ∏è Download as ZIP
          </button>
        </div>
      </div>
    </div>

    <footer class="text-center mt-8 text-sm text-gray-500">
      Source on GitHub:
      <a href="https://github.com/phamthainb/kubectl-neat-for-web" target="_blank" class="text-blue-500 hover:underline">
        https://github.com/phamthainb/kubectl-neat-for-web
      </a>
    </footer>
  </div>

  <script>
    // Global variables to track processed files
    let processedFiles = [];
    let isMultipleFiles = false;
    
    // Editor instances
    let inputEditor = null;
    let outputEditor = null;
    
    // Custom editor implementation with syntax highlighting
    class YamlEditor {
      constructor(containerId, readonly = false) {
        this.container = document.querySelector(`#${containerId}`).parentElement;
        this.textarea = document.getElementById(containerId);
        this.highlight = document.getElementById(`${containerId}-highlight`);
        this.lineNumbers = document.getElementById(`${containerId}-line-numbers`);
        this.readonly = readonly;
        
        this.init();
      }
      
      init() {
        // Set up event listeners
        this.textarea.addEventListener('input', () => this.handleInput());
        this.textarea.addEventListener('scroll', () => this.handleScroll());
        this.textarea.addEventListener('keydown', (e) => this.handleKeydown(e));
        
        // Initial highlight
        this.updateHighlight();
        this.updateLineNumbers();
      }
      
      handleInput() {
        this.updateHighlight();
        this.updateLineNumbers();
      }
      
      handleScroll() {
        this.highlight.scrollTop = this.textarea.scrollTop;
        this.highlight.scrollLeft = this.textarea.scrollLeft;
        this.lineNumbers.scrollTop = this.textarea.scrollTop;
      }
      
      handleKeydown(e) {
        // Handle tab key for proper indentation
        if (e.key === 'Tab') {
          e.preventDefault();
          const start = this.textarea.selectionStart;
          const end = this.textarea.selectionEnd;
          const value = this.textarea.value;
          
          if (e.shiftKey) {
            // Shift+Tab: remove indentation
            const lineStart = value.lastIndexOf('\n', start - 1) + 1;
            const lineEnd = value.indexOf('\n', start);
            const line = value.substring(lineStart, lineEnd === -1 ? value.length : lineEnd);
            
            if (line.startsWith('  ')) {
              this.textarea.value = value.substring(0, lineStart) + line.substring(2) + value.substring(lineEnd === -1 ? value.length : lineEnd);
              this.textarea.selectionStart = Math.max(lineStart, start - 2);
              this.textarea.selectionEnd = Math.max(lineStart, end - 2);
            }
          } else {
            // Tab: add indentation
            this.textarea.value = value.substring(0, start) + '  ' + value.substring(end);
            this.textarea.selectionStart = this.textarea.selectionEnd = start + 2;
          }
          
          this.updateHighlight();
          this.updateLineNumbers();
        }
      }
      
      updateHighlight() {
        const text = this.textarea.value;
        
        if (typeof hljs !== 'undefined') {
          try {
            const highlighted = hljs.highlight(text, { language: 'yaml' }).value;
            this.highlight.innerHTML = highlighted;
          } catch (e) {
            // Fallback to plain text if highlighting fails
            this.highlight.textContent = text;
          }
        } else {
          // Simple fallback highlighting without hljs
          this.highlight.innerHTML = this.simpleYamlHighlight(text);
        }
      }
      
      simpleYamlHighlight(text) {
        return text
          .replace(/^(\s*)([\w-]+)(\s*:\s*)/gm, '$1<span style="color: #0066cc; font-weight: bold;">$2</span>$3')
          .replace(/(:\s*)([\w\d\.\-\/]+)$/gm, '$1<span style="color: #669900;">$2</span>')
          .replace(/^(\s*#.*$)/gm, '<span style="color: #999; font-style: italic;">$1</span>')
          .replace(/(["'])([^"']*)\1/g, '<span style="color: #dd1144;">$1$2$1</span>')
          .replace(/^(\s*-\s*)/gm, '$1');
      }
      
      updateLineNumbers() {
        const lines = this.textarea.value.split('\n');
        const lineNumbersHtml = lines.map((_, index) => index + 1).join('\n');
        this.lineNumbers.textContent = lineNumbersHtml;
      }
      
      getValue() {
        return this.textarea.value;
      }
      
      setValue(value) {
        this.textarea.value = value;
        this.updateHighlight();
        this.updateLineNumbers();
      }
    }
    
    // Initialize editors
    function initializeEditors() {
      inputEditor = new YamlEditor('input', false);
      outputEditor = new YamlEditor('output', true);
      
      // Set initial content
      inputEditor.setValue('# Paste your kubectl YAML here...');
      outputEditor.setValue('# Results will appear here...');
    }
    
    // Initialize editors when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Wait a bit for hljs to load, then initialize
      setTimeout(() => {
        initializeEditors();
        initializeModeFromURL();
      }, 100);
    });

    // URL query parameter utilities
    function getQueryParam(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    function setQueryParam(name, value) {
      const url = new URL(window.location);
      url.searchParams.set(name, value);
      window.history.replaceState({}, '', url);
    }

    // Initialize mode from URL query parameter on page load
    function initializeModeFromURL() {
      const modeFromURL = getQueryParam('mode');
      if (modeFromURL === 'upload') {
        document.querySelector('input[name="mode"][value="upload"]').checked = true;
        toggleInputMode();
      } else {
        // Default to paste mode if no valid query parameter
        document.querySelector('input[name="mode"][value="paste"]').checked = true;
        setQueryParam('mode', 'paste');
      }
    }

    function toggleInputMode() {
      const mode = document.querySelector('input[name="mode"]:checked').value;
      const pasteContainer = document.getElementById("pasteContainer");
      const uploadContainer = document.getElementById("uploadContainer");
      
      if (mode === "paste") {
        pasteContainer.style.display = "block";
        uploadContainer.style.display = "none";
      } else {
        pasteContainer.style.display = "none";
        uploadContainer.style.display = "block";
      }
      
      // Update URL query parameter
      setQueryParam('mode', mode);
      
      // Reset file tracking when switching modes
      if (mode === "paste") {
        processedFiles = [];
        isMultipleFiles = false;
      }
    }

    function processFiles(files) {
      const yamlFiles = Array.from(files).filter(file => 
        file.name.toLowerCase().endsWith('.yaml') || 
        file.name.toLowerCase().endsWith('.yml')
      );
      
      if (yamlFiles.length === 0) {
        alert('No YAML files found in selection.');
        return;
      }

      // Reset tracking
      processedFiles = [];
      isMultipleFiles = yamlFiles.length > 1;

      let combinedContent = '';
      let processedCount = 0;
      
      yamlFiles.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function (e) {
          // Store individual file info
          processedFiles.push({
            name: file.name,
            originalContent: e.target.result,
            path: file.webkitRelativePath || file.name
          });

          if (combinedContent && e.target.result.trim()) {
            combinedContent += '\n---\n';
          }
          combinedContent += e.target.result;
          processedCount++;
          
          // Update input field when all files are processed
          if (processedCount === yamlFiles.length) {
            document.getElementById("input").value = combinedContent;
            // Update CodeMirror editor if available
            if (inputEditor) {
              inputEditor.setValue(combinedContent);
            }
          }
        };
        reader.onerror = function() {
          console.error(`Error reading file: ${file.name}`);
          processedCount++;
          if (processedCount === yamlFiles.length) {
            document.getElementById("input").value = combinedContent;
            // Update CodeMirror editor if available
            if (inputEditor) {
              inputEditor.setValue(combinedContent);
            }
          }
        };
        reader.readAsText(file);
      });
    }

    document.getElementById("fileInput").addEventListener("change", function (event) {
      processFiles(event.target.files);
    });

    document.getElementById("folderInput").addEventListener("change", function (event) {
      processFiles(event.target.files);
    });

    function neat() {
      // Get input from editor or fallback to textarea
      const inputText = inputEditor ? inputEditor.getValue() : document.getElementById("input").value;
      let output = "";
      let processedDocuments = [];

      try {
        // Try different YAML library global names
        let yamlLib = null;
        if (typeof jsyaml !== 'undefined') {
          yamlLib = jsyaml;
        } else if (typeof jsYAML !== 'undefined') {
          yamlLib = jsYAML;
        } else if (typeof window.jsyaml !== 'undefined') {
          yamlLib = window.jsyaml;
        } else if (typeof window.jsYAML !== 'undefined') {
          yamlLib = window.jsYAML;
        }

        if (yamlLib) {
          if (processedFiles.length > 0) {
            // Process each file individually to maintain file structure
            processedFiles.forEach(file => {
              try {
                const documents = yamlLib.loadAll(file.originalContent);
                const cleanedDocs = documents.map(doc => stripFields(doc));
                const cleanedYaml = cleanedDocs.map(doc => yamlLib.dump(doc, { noRefs: true })).join('---\n');
                
                processedDocuments.push({
                  name: file.name,
                  path: file.path,
                  content: cleanedYaml
                });
              } catch (err) {
                console.error(`Error processing file ${file.name}:`, err);
                processedDocuments.push({
                  name: file.name,
                  path: file.path,
                  content: `# Error processing file: ${err.message}`
                });
              }
            });
            
            // Combine all for display
            output = processedDocuments.map(doc => doc.content).join('\n---\n');
          } else {
            // Single paste mode
            const documents = yamlLib.loadAll(inputText);
            const cleanedDocs = documents.map(doc => stripFields(doc));
            output = cleanedDocs.map(doc => yamlLib.dump(doc, { noRefs: true })).join('---\n');
            
            processedDocuments = [{
              name: 'kubectl-neat-output.yaml',
              path: 'kubectl-neat-output.yaml',
              content: output
            }];
          }
        } else {
          // Fallback: Simple text processing for demo purposes
          const parts = inputText.split(/^---$/m).map(part => part.trim()).filter(part => part);
          const cleanedParts = parts.map(part => 
            part
              .replace(/\s+status:\s*[\s\S]*?(?=\n[a-zA-Z]|\n$|$)/g, '') // Remove status sections
              .replace(/\s+creationTimestamp:.*$/gm, '') // Remove creationTimestamp
              .replace(/\s+resourceVersion:.*$/gm, '') // Remove resourceVersion
              .replace(/\s+uid:.*$/gm, '') // Remove uid
              .replace(/\s+generation:.*$/gm, '') // Remove generation
              .replace(/\s+managedFields:\s*[\s\S]*?(?=\n[a-zA-Z]|\n$|$)/g, '') // Remove managedFields
              .replace(/\n\s*\n/g, '\n') // Remove empty lines
              .trim()
          );
          
          output = cleanedParts.join('\n---\n');
          
          processedDocuments = [{
            name: 'kubectl-neat-output.yaml',
            path: 'kubectl-neat-output.yaml',
            content: output
          }];
          
          output += '\n\n# Note: Using fallback text processing. For full YAML parsing, ensure internet connection.';
        }
      } catch (err) {
        output = "‚ùå Error parsing YAML: " + err.message;
      }

      document.getElementById("output").value = output;
      
      // Update output editor if available
      if (outputEditor) {
        outputEditor.setValue(output);
      }
      
      // Show download section and update buttons
      showDownloadOptions(processedDocuments);
    }

    function showDownloadOptions(processedDocuments) {
      const downloadSection = document.getElementById("downloadSection");
      const downloadMultiple = document.getElementById("downloadMultiple");
      const downloadZip = document.getElementById("downloadZip");
      
      downloadSection.style.display = "block";
      
      // Store processed documents globally for download functions
      window.currentProcessedDocuments = processedDocuments;
      
      if (processedDocuments.length > 1) {
        downloadMultiple.style.display = "inline-block";
        downloadZip.style.display = "inline-block";
      } else {
        downloadMultiple.style.display = "none";
        downloadZip.style.display = "none";
      }
    }

    async function copyToClipboard() {
      // Get output from editor or fallback to textarea
      const output = outputEditor ? outputEditor.getValue() : document.getElementById("output").value;
      if (!output || output.includes("‚ùå Error")) {
        alert("No valid output to copy");
        return;
      }
      
      try {
        await navigator.clipboard.writeText(output);
        
        // Visual feedback
        const copyButton = document.getElementById("copyButton");
        const originalText = copyButton.innerHTML;
        copyButton.innerHTML = "‚úÖ Copied!";
        copyButton.classList.remove("bg-blue-600", "hover:bg-blue-700");
        copyButton.classList.add("bg-green-600", "hover:bg-green-700");
        
        setTimeout(() => {
          copyButton.innerHTML = originalText;
          copyButton.classList.remove("bg-green-600", "hover:bg-green-700");
          copyButton.classList.add("bg-blue-600", "hover:bg-blue-700");
        }, 2000);
        
      } catch (err) {
        // Fallback for older browsers - use the textarea for selection
        const textarea = document.getElementById("output");
        textarea.style.display = 'block';
        textarea.style.position = 'absolute';
        textarea.style.left = '-9999px';
        textarea.select();
        textarea.setSelectionRange(0, 99999); // For mobile devices
        
        try {
          document.execCommand('copy');
          
          // Visual feedback for fallback
          const copyButton = document.getElementById("copyButton");
          const originalText = copyButton.innerHTML;
          copyButton.innerHTML = "‚úÖ Copied!";
          copyButton.classList.remove("bg-blue-600", "hover:bg-blue-700");
          copyButton.classList.add("bg-green-600", "hover:bg-green-700");
          
          setTimeout(() => {
            copyButton.innerHTML = originalText;
            copyButton.classList.remove("bg-green-600", "hover:bg-green-700");
            copyButton.classList.add("bg-blue-600", "hover:bg-blue-700");
          }, 2000);
          
        } catch (fallbackErr) {
          alert("Copy failed. Please manually select and copy the text.");
        } finally {
          // Hide the textarea again
          const textarea = document.getElementById("output");
          textarea.style.display = 'none';
        }
      }
    }

    function downloadSingleFile() {
      // Get output from editor or fallback to textarea
      const output = outputEditor ? outputEditor.getValue() : document.getElementById("output").value;
      if (!output || output.includes("‚ùå Error")) {
        alert("No valid output to download");
        return;
      }
      
      const fileName = window.currentProcessedDocuments && window.currentProcessedDocuments.length === 1 
        ? window.currentProcessedDocuments[0].name 
        : 'kubectl-neat-output.yaml';
      
      downloadFile(output, fileName);
    }

    function downloadMultipleFiles() {
      if (!window.currentProcessedDocuments || window.currentProcessedDocuments.length <= 1) {
        alert("No multiple files to download");
        return;
      }
      
      window.currentProcessedDocuments.forEach(doc => {
        downloadFile(doc.content, doc.name);
      });
    }

    async function downloadAsZip() {
      if (!window.currentProcessedDocuments || window.currentProcessedDocuments.length <= 1) {
        alert("No multiple files to download as ZIP");
        return;
      }
      
      try {
        const zip = new JSZip();
        
        window.currentProcessedDocuments.forEach(doc => {
          // Use the original path structure if available
          const filePath = doc.path || doc.name;
          zip.file(filePath, doc.content);
        });
        
        const content = await zip.generateAsync({type: "blob"});
        const fileName = "kubectl-neat-output.zip";
        
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
      } catch (err) {
        alert("Error creating ZIP file: " + err.message);
      }
    }

    function downloadFile(content, fileName) {
      const blob = new Blob([content], { type: 'text/yaml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    }

    function stripFields(obj) {
      const skipMetadata = [
        "creationTimestamp", "resourceVersion", "selfLink",
        "uid", "generation", "managedFields"
      ];

      if (typeof obj !== "object" || obj === null) return obj;

      const newObj = Array.isArray(obj) ? [] : {};
      for (const key in obj) {
        if (
          key === "status" ||
          (key === "metadata" && typeof obj[key] === "object")
        ) {
          if (key === "metadata") {
            newObj[key] = {};
            for (const metaKey in obj[key]) {
              if (!skipMetadata.includes(metaKey)) {
                newObj[key][metaKey] = stripFields(obj[key][metaKey]);
              }
            }
          }
        } else if (key !== "status") {
          newObj[key] = stripFields(obj[key]);
        }
      }
      return newObj;
    }

    // Initialize mode from URL when page loads (moved to DOMContentLoaded above)
  </script>
</body>
</html>
